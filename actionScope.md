# 作用域

## 闭包

* 闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放
* 闭包实现的关键：创建他的上下文已经销毁，而它仍然存在
* 闭包实现的原因：内部存在对外部作用域的引用

## This

### 五种绑定

#### 默认绑定

* 独立函数调用，可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。
* 严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下调用函数则不影响默认绑定。

#### 隐式绑定

* 当函数引用有上下文对象时，隐式绑定规则会把函数中的this绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用中起作用
* 被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上

```javascript
    function foo() {
        console.log( this.a );
    }
    var obj = {
        a: 2,
        foo: foo
    };
    var bar = obj.foo; // 函数别名
    var a = "oops, global"; // a是全局对象的属性
    bar(); // "oops, global"
```

#### 显式绑定

* 通过call(..) 或者 apply(..)方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定
* 显示绑定无法解决丢失绑定问题

##### 丢失绑定解决方案

* 硬绑定-返回包裹执行apply/call的函数或者用bind
* API调用的"上下文"
